<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flipper Zero Firmware: /Users/astrr/flipper/flipperzero-firmware/firmware/targets/f7/ble_glue/hw_conf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Flipper Zero Firmware
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d9edf6c004b4a7ff14fe9ae7a92214ee.html">firmware</a></li><li class="navelem"><a class="el" href="dir_2d21308063d3b2f2dd74554ae427596f.html">targets</a></li><li class="navelem"><a class="el" href="dir_1f97ac513b55c3b4fca43ced46ea9f5b.html">f7</a></li><li class="navelem"><a class="el" href="dir_b74733ffbc3476b60a93aff475fef185.html">ble_glue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">hw_conf.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Configuration of hardware interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;FreeRTOSConfig.h&quot;</code><br />
</div>
<p><a href="hw__conf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae453b8043c163ec99a492f39934c0092"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__conf_8h.html#ae453b8043c163ec99a492f39934c0092">CFG_HW_PWR_STANDBY_SEMID</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:ae453b8043c163ec99a492f39934c0092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the semaphore used the prevent conflicts after standby sleep.  <a href="hw__conf_8h.html#ae453b8043c163ec99a492f39934c0092">More...</a><br /></td></tr>
<tr class="separator:ae453b8043c163ec99a492f39934c0092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ffd7ce57717af843e0d8fa47e2f70f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__conf_8h.html#a33ffd7ce57717af843e0d8fa47e2f70f">CFG_HW_THREAD_NVM_SRAM_SEMID</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a33ffd7ce57717af843e0d8fa47e2f70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CPU2 may be configured to store the Thread persistent data either in internal NVM storage on CPU2 or in SRAM2 buffer provided by the user application.  <a href="hw__conf_8h.html#a33ffd7ce57717af843e0d8fa47e2f70f">More...</a><br /></td></tr>
<tr class="separator:a33ffd7ce57717af843e0d8fa47e2f70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd830b43f8b88f90e13aa0b07db86fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__conf_8h.html#a6bd830b43f8b88f90e13aa0b07db86fe">CFG_HW_BLE_NVM_SRAM_SEMID</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a6bd830b43f8b88f90e13aa0b07db86fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CPU2 may be configured to store the BLE persistent data either in internal NVM storage on CPU2 or in SRAM2 buffer provided by the user application.  <a href="hw__conf_8h.html#a6bd830b43f8b88f90e13aa0b07db86fe">More...</a><br /></td></tr>
<tr class="separator:a6bd830b43f8b88f90e13aa0b07db86fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32646bd78e0f5e56196713d0a38b551"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__conf_8h.html#af32646bd78e0f5e56196713d0a38b551">CFG_HW_BLOCK_FLASH_REQ_BY_CPU2_SEMID</a>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:af32646bd78e0f5e56196713d0a38b551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the semaphore used by CPU2 to prevent the CPU1 to either write or erase data in flash The CPU1 shall not either write or erase in flash when this semaphore is taken by the CPU2 When the CPU1 needs to either write or erase in flash, it shall first get the semaphore and release it just after writing a raw (64bits data) or erasing one sector.  <a href="hw__conf_8h.html#af32646bd78e0f5e56196713d0a38b551">More...</a><br /></td></tr>
<tr class="separator:af32646bd78e0f5e56196713d0a38b551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d92470a355fcab2af3b1c77377f367"><td class="memItemLeft" align="right" valign="top"><a id="a47d92470a355fcab2af3b1c77377f367" name="a47d92470a355fcab2af3b1c77377f367"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_BLOCK_FLASH_REQ_BY_CPU1_SEMID</b>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a47d92470a355fcab2af3b1c77377f367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the semaphore used by CPU1 to prevent the CPU2 to either write or erase data in flash In order to protect its timing, the CPU1 may get this semaphore to prevent the CPU2 to either write or erase in flash (as this will stall both CPUs) The PES bit shall not be used as this may stall the CPU2 in some cases. <br /></td></tr>
<tr class="separator:a47d92470a355fcab2af3b1c77377f367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e1feb234a7d92148b61341e619406c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__conf_8h.html#ac8e1feb234a7d92148b61341e619406c">CFG_HW_CLK48_CONFIG_SEMID</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:ac8e1feb234a7d92148b61341e619406c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the semaphore used to manage the CLK48 clock configuration When the USB is required, this semaphore shall be taken before configuring te CLK48 for USB and should be released after the application switch OFF the clock when the USB is not used anymore When using the RNG, it is good enough to use CFG_HW_RNG_SEMID to control CLK48.  <a href="hw__conf_8h.html#ac8e1feb234a7d92148b61341e619406c">More...</a><br /></td></tr>
<tr class="separator:ac8e1feb234a7d92148b61341e619406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a932807c2abe1b5a58a203bad318b9"><td class="memItemLeft" align="right" valign="top"><a id="aa6a932807c2abe1b5a58a203bad318b9" name="aa6a932807c2abe1b5a58a203bad318b9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_ENTRY_STOP_MODE_SEMID</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:aa6a932807c2abe1b5a58a203bad318b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac138b73973094a8f1f85668743d0fe"><td class="memItemLeft" align="right" valign="top"><a id="a6ac138b73973094a8f1f85668743d0fe" name="a6ac138b73973094a8f1f85668743d0fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_RCC_SEMID</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a6ac138b73973094a8f1f85668743d0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629b27519f1cffbc1abaa6882d729b32"><td class="memItemLeft" align="right" valign="top"><a id="a629b27519f1cffbc1abaa6882d729b32" name="a629b27519f1cffbc1abaa6882d729b32"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_FLASH_SEMID</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a629b27519f1cffbc1abaa6882d729b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc651f85070efd8d0fd3ba516543d74"><td class="memItemLeft" align="right" valign="top"><a id="aafc651f85070efd8d0fd3ba516543d74" name="aafc651f85070efd8d0fd3ba516543d74"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_PKA_SEMID</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aafc651f85070efd8d0fd3ba516543d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff99ecf3081f747672be2c4341a52e7"><td class="memItemLeft" align="right" valign="top"><a id="aaff99ecf3081f747672be2c4341a52e7" name="aaff99ecf3081f747672be2c4341a52e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_RNG_SEMID</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:aaff99ecf3081f747672be2c4341a52e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d96796369010ac19baec44a11fce3c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__conf_8h.html#a2d96796369010ac19baec44a11fce3c3">CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a2d96796369010ac19baec44a11fce3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user may define the maximum number of virtual timers supported.  <a href="hw__conf_8h.html#a2d96796369010ac19baec44a11fce3c3">More...</a><br /></td></tr>
<tr class="separator:a2d96796369010ac19baec44a11fce3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c36ea61714eb54bacc5b28cfe461b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__conf_8h.html#a02c36ea61714eb54bacc5b28cfe461b7">CFG_HW_TS_NVIC_RTC_WAKEUP_IT_PREEMPTPRIO</a>&#160;&#160;&#160;    (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY + 1) /* FreeRTOS requirement */</td></tr>
<tr class="memdesc:a02c36ea61714eb54bacc5b28cfe461b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user may define the priority in the NVIC of the RTC_WKUP interrupt handler that is used to manage the wakeup timer.  <a href="hw__conf_8h.html#a02c36ea61714eb54bacc5b28cfe461b7">More...</a><br /></td></tr>
<tr class="separator:a02c36ea61714eb54bacc5b28cfe461b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464b56d7953e83306d7231a4f97a80d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__conf_8h.html#a464b56d7953e83306d7231a4f97a80d4">CFG_HW_TS_NVIC_RTC_WAKEUP_IT_SUBPRIO</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a464b56d7953e83306d7231a4f97a80d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user may define the priority in the NVIC of the RTC_WKUP interrupt handler that is used to manage the wakeup timer.  <a href="hw__conf_8h.html#a464b56d7953e83306d7231a4f97a80d4">More...</a><br /></td></tr>
<tr class="separator:a464b56d7953e83306d7231a4f97a80d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaf86fa3ec27befff69aa4c429b9bff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__conf_8h.html#a3eaf86fa3ec27befff69aa4c429b9bff">CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a3eaf86fa3ec27befff69aa4c429b9bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a critical section in the Timer server The Timer server does not support the API to be nested The Application shall either: a) Ensure this will never happen b) Define the critical section The default implementations is masking all interrupts using the PRIMASK bit The TimerServer driver uses critical sections to avoid context corruption.  <a href="hw__conf_8h.html#a3eaf86fa3ec27befff69aa4c429b9bff">More...</a><br /></td></tr>
<tr class="separator:a3eaf86fa3ec27befff69aa4c429b9bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa1fb93ee056623cf5422b462ad86ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hw__conf_8h.html#a3fa1fb93ee056623cf5422b462ad86ea">CFG_HW_TS_RTC_HANDLER_MAX_DELAY</a>&#160;&#160;&#160;(10 * (LSI_VALUE / 1000))</td></tr>
<tr class="memdesc:a3fa1fb93ee056623cf5422b462ad86ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value shall reflect the maximum delay there could be in the application between the time the RTC interrupt is generated by the Hardware and the time when the RTC interrupt handler is called.  <a href="hw__conf_8h.html#a3fa1fb93ee056623cf5422b462ad86ea">More...</a><br /></td></tr>
<tr class="separator:a3fa1fb93ee056623cf5422b462ad86ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25731ccca96dfd44f211bf48f666c82"><td class="memItemLeft" align="right" valign="top"><a id="ab25731ccca96dfd44f211bf48f666c82" name="ab25731ccca96dfd44f211bf48f666c82"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_TS_RTC_WAKEUP_HANDLER_ID</b>&#160;&#160;&#160;RTC_WKUP_IRQn</td></tr>
<tr class="memdesc:ab25731ccca96dfd44f211bf48f666c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt ID in the NVIC of the RTC Wakeup interrupt handler It shall be type of IRQn_Type. <br /></td></tr>
<tr class="separator:ab25731ccca96dfd44f211bf48f666c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90eed3f0630ecc5515852f228c7ba551"><td class="memItemLeft" align="right" valign="top"><a id="a90eed3f0630ecc5515852f228c7ba551" name="a90eed3f0630ecc5515852f228c7ba551"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_LPUART1_ENABLED</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a90eed3f0630ecc5515852f228c7ba551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d179b0b5c1216e5b5e92ce8464df09"><td class="memItemLeft" align="right" valign="top"><a id="ae2d179b0b5c1216e5b5e92ce8464df09" name="ae2d179b0b5c1216e5b5e92ce8464df09"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_LPUART1_DMA_TX_SUPPORTED</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ae2d179b0b5c1216e5b5e92ce8464df09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d25437dc3130244b72dc38217e64c5"><td class="memItemLeft" align="right" valign="top"><a id="ad8d25437dc3130244b72dc38217e64c5" name="ad8d25437dc3130244b72dc38217e64c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_ENABLED</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ad8d25437dc3130244b72dc38217e64c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7948523736716e554e6c8eefa8122e21"><td class="memItemLeft" align="right" valign="top"><a id="a7948523736716e554e6c8eefa8122e21" name="a7948523736716e554e6c8eefa8122e21"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_DMA_TX_SUPPORTED</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a7948523736716e554e6c8eefa8122e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a92ba41479f6dda82b74b1aebac8a8a"><td class="memItemLeft" align="right" valign="top"><a id="a3a92ba41479f6dda82b74b1aebac8a8a" name="a3a92ba41479f6dda82b74b1aebac8a8a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_PREEMPTPRIORITY</b>&#160;&#160;&#160;0x0F</td></tr>
<tr class="memdesc:a3a92ba41479f6dda82b74b1aebac8a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART1. <br /></td></tr>
<tr class="separator:a3a92ba41479f6dda82b74b1aebac8a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5906fdd130634500da4994ff7740be"><td class="memItemLeft" align="right" valign="top"><a id="a6c5906fdd130634500da4994ff7740be" name="a6c5906fdd130634500da4994ff7740be"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_SUBPRIORITY</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a6c5906fdd130634500da4994ff7740be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd960b1f93d9eba2517d03987dc406f"><td class="memItemLeft" align="right" valign="top"><a id="a5cd960b1f93d9eba2517d03987dc406f" name="a5cd960b1f93d9eba2517d03987dc406f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_SOURCE_CLOCK</b>&#160;&#160;&#160;RCC_USART1CLKSOURCE_SYSCLK</td></tr>
<tr class="memdesc:a5cd960b1f93d9eba2517d03987dc406f"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; The application shall check the selected source clock is enable <br /></td></tr>
<tr class="separator:a5cd960b1f93d9eba2517d03987dc406f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad932aa5e64fbd2486767a229fb9f9641"><td class="memItemLeft" align="right" valign="top"><a id="ad932aa5e64fbd2486767a229fb9f9641" name="ad932aa5e64fbd2486767a229fb9f9641"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_BAUDRATE</b>&#160;&#160;&#160;115200</td></tr>
<tr class="separator:ad932aa5e64fbd2486767a229fb9f9641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9463e1f6c826d86be4cca422f47b5678"><td class="memItemLeft" align="right" valign="top"><a id="a9463e1f6c826d86be4cca422f47b5678" name="a9463e1f6c826d86be4cca422f47b5678"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_WORDLENGTH</b>&#160;&#160;&#160;UART_WORDLENGTH_8B</td></tr>
<tr class="separator:a9463e1f6c826d86be4cca422f47b5678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0d29c642c2f19f26e3fc35a25120cb"><td class="memItemLeft" align="right" valign="top"><a id="abf0d29c642c2f19f26e3fc35a25120cb" name="abf0d29c642c2f19f26e3fc35a25120cb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_STOPBITS</b>&#160;&#160;&#160;UART_STOPBITS_1</td></tr>
<tr class="separator:abf0d29c642c2f19f26e3fc35a25120cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52ade0c3c3c92b7733bc6454eb165ec"><td class="memItemLeft" align="right" valign="top"><a id="aa52ade0c3c3c92b7733bc6454eb165ec" name="aa52ade0c3c3c92b7733bc6454eb165ec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_PARITY</b>&#160;&#160;&#160;UART_PARITY_NONE</td></tr>
<tr class="separator:aa52ade0c3c3c92b7733bc6454eb165ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad061980d30f6fd9e9331fbc204ec21df"><td class="memItemLeft" align="right" valign="top"><a id="ad061980d30f6fd9e9331fbc204ec21df" name="ad061980d30f6fd9e9331fbc204ec21df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_HWFLOWCTL</b>&#160;&#160;&#160;UART_HWCONTROL_NONE</td></tr>
<tr class="separator:ad061980d30f6fd9e9331fbc204ec21df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8095aaee35f63464cf1ec82787dede5"><td class="memItemLeft" align="right" valign="top"><a id="ad8095aaee35f63464cf1ec82787dede5" name="ad8095aaee35f63464cf1ec82787dede5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_MODE</b>&#160;&#160;&#160;UART_MODE_TX_RX</td></tr>
<tr class="separator:ad8095aaee35f63464cf1ec82787dede5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ebc7c5c4d2576e31d4ded479dc02d1"><td class="memItemLeft" align="right" valign="top"><a id="a79ebc7c5c4d2576e31d4ded479dc02d1" name="a79ebc7c5c4d2576e31d4ded479dc02d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_ADVFEATUREINIT</b>&#160;&#160;&#160;UART_ADVFEATURE_NO_INIT</td></tr>
<tr class="separator:a79ebc7c5c4d2576e31d4ded479dc02d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1118071f35e5deed19392c69f5011940"><td class="memItemLeft" align="right" valign="top"><a id="a1118071f35e5deed19392c69f5011940" name="a1118071f35e5deed19392c69f5011940"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_OVERSAMPLING</b>&#160;&#160;&#160;UART_OVERSAMPLING_8</td></tr>
<tr class="separator:a1118071f35e5deed19392c69f5011940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19457ed7440c803022278319cb737d89"><td class="memItemLeft" align="right" valign="top"><a id="a19457ed7440c803022278319cb737d89" name="a19457ed7440c803022278319cb737d89"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_TX_PORT_CLK_ENABLE</b>&#160;&#160;&#160;__HAL_RCC_GPIOB_CLK_ENABLE</td></tr>
<tr class="separator:a19457ed7440c803022278319cb737d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519ec54b9681a154b3f61da5b12c9c85"><td class="memItemLeft" align="right" valign="top"><a id="a519ec54b9681a154b3f61da5b12c9c85" name="a519ec54b9681a154b3f61da5b12c9c85"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_TX_PORT</b>&#160;&#160;&#160;GPIOB</td></tr>
<tr class="separator:a519ec54b9681a154b3f61da5b12c9c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ee6648c8a77bfc0b1189750e870acf"><td class="memItemLeft" align="right" valign="top"><a id="ae2ee6648c8a77bfc0b1189750e870acf" name="ae2ee6648c8a77bfc0b1189750e870acf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_TX_PIN</b>&#160;&#160;&#160;GPIO_PIN_6</td></tr>
<tr class="separator:ae2ee6648c8a77bfc0b1189750e870acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceb0f0e9a8b1bd663eb005674b75ec1"><td class="memItemLeft" align="right" valign="top"><a id="a4ceb0f0e9a8b1bd663eb005674b75ec1" name="a4ceb0f0e9a8b1bd663eb005674b75ec1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_TX_MODE</b>&#160;&#160;&#160;GPIO_MODE_AF_PP</td></tr>
<tr class="separator:a4ceb0f0e9a8b1bd663eb005674b75ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38e521d1dd081af165d70fe99a3f3a5"><td class="memItemLeft" align="right" valign="top"><a id="ae38e521d1dd081af165d70fe99a3f3a5" name="ae38e521d1dd081af165d70fe99a3f3a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_TX_PULL</b>&#160;&#160;&#160;GPIO_NOPULL</td></tr>
<tr class="separator:ae38e521d1dd081af165d70fe99a3f3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f355ba1f11402c8646470af5fd5eb3"><td class="memItemLeft" align="right" valign="top"><a id="aa8f355ba1f11402c8646470af5fd5eb3" name="aa8f355ba1f11402c8646470af5fd5eb3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_TX_SPEED</b>&#160;&#160;&#160;GPIO_SPEED_FREQ_VERY_HIGH</td></tr>
<tr class="separator:aa8f355ba1f11402c8646470af5fd5eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92961f7df6f66b417d9ffc4b161abd6"><td class="memItemLeft" align="right" valign="top"><a id="ae92961f7df6f66b417d9ffc4b161abd6" name="ae92961f7df6f66b417d9ffc4b161abd6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_TX_ALTERNATE</b>&#160;&#160;&#160;GPIO_AF7_USART1</td></tr>
<tr class="separator:ae92961f7df6f66b417d9ffc4b161abd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccf5c12fdc19c43cff665120482cf53"><td class="memItemLeft" align="right" valign="top"><a id="adccf5c12fdc19c43cff665120482cf53" name="adccf5c12fdc19c43cff665120482cf53"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_RX_PORT_CLK_ENABLE</b>&#160;&#160;&#160;__HAL_RCC_GPIOB_CLK_ENABLE</td></tr>
<tr class="separator:adccf5c12fdc19c43cff665120482cf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f20b979195fc61788065de80d22d5e"><td class="memItemLeft" align="right" valign="top"><a id="a45f20b979195fc61788065de80d22d5e" name="a45f20b979195fc61788065de80d22d5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_RX_PORT</b>&#160;&#160;&#160;GPIOB</td></tr>
<tr class="separator:a45f20b979195fc61788065de80d22d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1674985dc2c3f006fe8d8c1ddffb8681"><td class="memItemLeft" align="right" valign="top"><a id="a1674985dc2c3f006fe8d8c1ddffb8681" name="a1674985dc2c3f006fe8d8c1ddffb8681"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_RX_PIN</b>&#160;&#160;&#160;GPIO_PIN_7</td></tr>
<tr class="separator:a1674985dc2c3f006fe8d8c1ddffb8681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40552dc0169771d3cf58162ba79fcc1e"><td class="memItemLeft" align="right" valign="top"><a id="a40552dc0169771d3cf58162ba79fcc1e" name="a40552dc0169771d3cf58162ba79fcc1e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_RX_MODE</b>&#160;&#160;&#160;GPIO_MODE_AF_PP</td></tr>
<tr class="separator:a40552dc0169771d3cf58162ba79fcc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4350517f99f14f0142e34db16660aa79"><td class="memItemLeft" align="right" valign="top"><a id="a4350517f99f14f0142e34db16660aa79" name="a4350517f99f14f0142e34db16660aa79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_RX_PULL</b>&#160;&#160;&#160;GPIO_NOPULL</td></tr>
<tr class="separator:a4350517f99f14f0142e34db16660aa79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a04a0fa6acd5edf25da5dfba2c81938"><td class="memItemLeft" align="right" valign="top"><a id="a0a04a0fa6acd5edf25da5dfba2c81938" name="a0a04a0fa6acd5edf25da5dfba2c81938"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_RX_SPEED</b>&#160;&#160;&#160;GPIO_SPEED_FREQ_VERY_HIGH</td></tr>
<tr class="separator:a0a04a0fa6acd5edf25da5dfba2c81938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af827bf897003587d538cc48f476954c5"><td class="memItemLeft" align="right" valign="top"><a id="af827bf897003587d538cc48f476954c5" name="af827bf897003587d538cc48f476954c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_RX_ALTERNATE</b>&#160;&#160;&#160;GPIO_AF7_USART1</td></tr>
<tr class="separator:af827bf897003587d538cc48f476954c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf87dd65f4cd143ab3d9614c5ac38c9b"><td class="memItemLeft" align="right" valign="top"><a id="aaf87dd65f4cd143ab3d9614c5ac38c9b" name="aaf87dd65f4cd143ab3d9614c5ac38c9b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_CTS_PORT_CLK_ENABLE</b>&#160;&#160;&#160;__HAL_RCC_GPIOA_CLK_ENABLE</td></tr>
<tr class="separator:aaf87dd65f4cd143ab3d9614c5ac38c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18624516c56017f47d1121499e53382e"><td class="memItemLeft" align="right" valign="top"><a id="a18624516c56017f47d1121499e53382e" name="a18624516c56017f47d1121499e53382e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_CTS_PORT</b>&#160;&#160;&#160;GPIOA</td></tr>
<tr class="separator:a18624516c56017f47d1121499e53382e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebb6bf1d9daad57b954892b84ef29c1"><td class="memItemLeft" align="right" valign="top"><a id="a3ebb6bf1d9daad57b954892b84ef29c1" name="a3ebb6bf1d9daad57b954892b84ef29c1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_CTS_PIN</b>&#160;&#160;&#160;GPIO_PIN_11</td></tr>
<tr class="separator:a3ebb6bf1d9daad57b954892b84ef29c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540795e1dbdfcf1d7c26409aca9817dc"><td class="memItemLeft" align="right" valign="top"><a id="a540795e1dbdfcf1d7c26409aca9817dc" name="a540795e1dbdfcf1d7c26409aca9817dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_CTS_MODE</b>&#160;&#160;&#160;GPIO_MODE_AF_PP</td></tr>
<tr class="separator:a540795e1dbdfcf1d7c26409aca9817dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68be12516571fbcb0c22e5e2169e81c7"><td class="memItemLeft" align="right" valign="top"><a id="a68be12516571fbcb0c22e5e2169e81c7" name="a68be12516571fbcb0c22e5e2169e81c7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_CTS_PULL</b>&#160;&#160;&#160;GPIO_PULLDOWN</td></tr>
<tr class="separator:a68be12516571fbcb0c22e5e2169e81c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe84394ce9d4ca1793ab1374929c6671"><td class="memItemLeft" align="right" valign="top"><a id="abe84394ce9d4ca1793ab1374929c6671" name="abe84394ce9d4ca1793ab1374929c6671"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_CTS_SPEED</b>&#160;&#160;&#160;GPIO_SPEED_FREQ_VERY_HIGH</td></tr>
<tr class="separator:abe84394ce9d4ca1793ab1374929c6671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1439136c40437604f802aad0fc9072"><td class="memItemLeft" align="right" valign="top"><a id="a8c1439136c40437604f802aad0fc9072" name="a8c1439136c40437604f802aad0fc9072"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_CTS_ALTERNATE</b>&#160;&#160;&#160;GPIO_AF7_USART1</td></tr>
<tr class="separator:a8c1439136c40437604f802aad0fc9072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9517c2f49c8c81947b29f5400b963d"><td class="memItemLeft" align="right" valign="top"><a id="a7f9517c2f49c8c81947b29f5400b963d" name="a7f9517c2f49c8c81947b29f5400b963d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_DMA_TX_PREEMPTPRIORITY</b>&#160;&#160;&#160;0x0F</td></tr>
<tr class="separator:a7f9517c2f49c8c81947b29f5400b963d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52aaac978760346de40b7c914dc6a3cb"><td class="memItemLeft" align="right" valign="top"><a id="a52aaac978760346de40b7c914dc6a3cb" name="a52aaac978760346de40b7c914dc6a3cb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_DMA_TX_SUBPRIORITY</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a52aaac978760346de40b7c914dc6a3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d77917263587d6807135c491286871"><td class="memItemLeft" align="right" valign="top"><a id="a66d77917263587d6807135c491286871" name="a66d77917263587d6807135c491286871"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_DMAMUX_CLK_ENABLE</b>&#160;&#160;&#160;__HAL_RCC_DMAMUX1_CLK_ENABLE</td></tr>
<tr class="separator:a66d77917263587d6807135c491286871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aec3c33ba539f9fe9e653d952cb47ac"><td class="memItemLeft" align="right" valign="top"><a id="a6aec3c33ba539f9fe9e653d952cb47ac" name="a6aec3c33ba539f9fe9e653d952cb47ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_DMA_CLK_ENABLE</b>&#160;&#160;&#160;__HAL_RCC_DMA2_CLK_ENABLE</td></tr>
<tr class="separator:a6aec3c33ba539f9fe9e653d952cb47ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afeecbcdd7b41185cb0e1288bffa116"><td class="memItemLeft" align="right" valign="top"><a id="a2afeecbcdd7b41185cb0e1288bffa116" name="a2afeecbcdd7b41185cb0e1288bffa116"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_TX_DMA_REQ</b>&#160;&#160;&#160;DMA_REQUEST_USART1_TX</td></tr>
<tr class="separator:a2afeecbcdd7b41185cb0e1288bffa116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad1dafeac02c1ffaf0cf3ade256f96b"><td class="memItemLeft" align="right" valign="top"><a id="a3ad1dafeac02c1ffaf0cf3ade256f96b" name="a3ad1dafeac02c1ffaf0cf3ade256f96b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_TX_DMA_CHANNEL</b>&#160;&#160;&#160;DMA2_Channel4</td></tr>
<tr class="separator:a3ad1dafeac02c1ffaf0cf3ade256f96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d3bc8799cd1ffe621cc88cceba1e9e"><td class="memItemLeft" align="right" valign="top"><a id="ae0d3bc8799cd1ffe621cc88cceba1e9e" name="ae0d3bc8799cd1ffe621cc88cceba1e9e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_TX_DMA_IRQn</b>&#160;&#160;&#160;DMA2_Channel4_IRQn</td></tr>
<tr class="separator:ae0d3bc8799cd1ffe621cc88cceba1e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629a98777c79bfb5e37abd397108dab7"><td class="memItemLeft" align="right" valign="top"><a id="a629a98777c79bfb5e37abd397108dab7" name="a629a98777c79bfb5e37abd397108dab7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CFG_HW_USART1_DMA_TX_IRQHandler</b>&#160;&#160;&#160;DMA2_Channel4_IRQHandler</td></tr>
<tr class="separator:a629a98777c79bfb5e37abd397108dab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Configuration of hardware interface. </p>
<dl class="section author"><dt>Author</dt><dd>MCD Application Team</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd></dd></dl>
<h2><center>&copy; Copyright (c) 2019 STMicroelectronics. All rights reserved.</center></h2>
<p >This software component is licensed by ST under Ultimate Liberty license SLA0044, the "License"; You may not use this file except in compliance with the License. You may obtain a copy of the License at: www.st.com/SLA0044 </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6bd830b43f8b88f90e13aa0b07db86fe" name="a6bd830b43f8b88f90e13aa0b07db86fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd830b43f8b88f90e13aa0b07db86fe">&#9670;&nbsp;</a></span>CFG_HW_BLE_NVM_SRAM_SEMID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_HW_BLE_NVM_SRAM_SEMID&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CPU2 may be configured to store the BLE persistent data either in internal NVM storage on CPU2 or in SRAM2 buffer provided by the user application. </p>
<p >This can be configured with the system command SHCI_C2_Config() When the CPU2 is requested to store persistent data in SRAM2, it can write data in this buffer at any time when needed. In order to read consistent data with the CPU1 from the SRAM2 buffer, the flow should be: + CPU1 takes CFG_HW_BLE_NVM_SRAM_SEMID semaphore + CPU1 reads all persistent data from SRAM2 (most of the time, the goal is to write these data into an NVM managed by CPU1) + CPU1 releases CFG_HW_BLE_NVM_SRAM_SEMID semaphore CFG_HW_BLE_NVM_SRAM_SEMID semaphore makes sure CPU2 does not update the persistent data in SRAM2 at the same time CPU1 is reading them. There is no timing constraint on how long this semaphore can be kept. </p>

</div>
</div>
<a id="af32646bd78e0f5e56196713d0a38b551" name="af32646bd78e0f5e56196713d0a38b551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32646bd78e0f5e56196713d0a38b551">&#9670;&nbsp;</a></span>CFG_HW_BLOCK_FLASH_REQ_BY_CPU2_SEMID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_HW_BLOCK_FLASH_REQ_BY_CPU2_SEMID&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of the semaphore used by CPU2 to prevent the CPU1 to either write or erase data in flash The CPU1 shall not either write or erase in flash when this semaphore is taken by the CPU2 When the CPU1 needs to either write or erase in flash, it shall first get the semaphore and release it just after writing a raw (64bits data) or erasing one sector. </p>
<p >Once the Semaphore has been released, there shall be at least 1us before it can be taken again. This is required to give the opportunity to CPU2 to take it. On v1.4.0 and older CPU2 wireless firmware, this semaphore is unused and CPU2 is using PES bit. By default, CPU2 is using the PES bit to protect its timing. The CPU1 may request the CPU2 to use the semaphore instead of the PES bit by sending the system command SHCI_C2_SetFlashActivityControl() </p>

</div>
</div>
<a id="ac8e1feb234a7d92148b61341e619406c" name="ac8e1feb234a7d92148b61341e619406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e1feb234a7d92148b61341e619406c">&#9670;&nbsp;</a></span>CFG_HW_CLK48_CONFIG_SEMID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_HW_CLK48_CONFIG_SEMID&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of the semaphore used to manage the CLK48 clock configuration When the USB is required, this semaphore shall be taken before configuring te CLK48 for USB and should be released after the application switch OFF the clock when the USB is not used anymore When using the RNG, it is good enough to use CFG_HW_RNG_SEMID to control CLK48. </p>
<p >More details in AN5289 </p>

</div>
</div>
<a id="ae453b8043c163ec99a492f39934c0092" name="ae453b8043c163ec99a492f39934c0092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae453b8043c163ec99a492f39934c0092">&#9670;&nbsp;</a></span>CFG_HW_PWR_STANDBY_SEMID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_HW_PWR_STANDBY_SEMID&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of the semaphore used the prevent conflicts after standby sleep. </p>
<p >Each CPUs takes this semaphore at standby wakeup until conclicting elements are restored. </p>

</div>
</div>
<a id="a33ffd7ce57717af843e0d8fa47e2f70f" name="a33ffd7ce57717af843e0d8fa47e2f70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ffd7ce57717af843e0d8fa47e2f70f">&#9670;&nbsp;</a></span>CFG_HW_THREAD_NVM_SRAM_SEMID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_HW_THREAD_NVM_SRAM_SEMID&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CPU2 may be configured to store the Thread persistent data either in internal NVM storage on CPU2 or in SRAM2 buffer provided by the user application. </p>
<p >This can be configured with the system command SHCI_C2_Config() When the CPU2 is requested to store persistent data in SRAM2, it can write data in this buffer at any time when needed. In order to read consistent data with the CPU1 from the SRAM2 buffer, the flow should be: + CPU1 takes CFG_HW_THREAD_NVM_SRAM_SEMID semaphore + CPU1 reads all persistent data from SRAM2 (most of the time, the goal is to write these data into an NVM managed by CPU1) + CPU1 releases CFG_HW_THREAD_NVM_SRAM_SEMID semaphore CFG_HW_THREAD_NVM_SRAM_SEMID semaphore makes sure CPU2 does not update the persistent data in SRAM2 at the same time CPU1 is reading them. There is no timing constraint on how long this semaphore can be kept. </p>

</div>
</div>
<a id="a2d96796369010ac19baec44a11fce3c3" name="a2d96796369010ac19baec44a11fce3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d96796369010ac19baec44a11fce3c3">&#9670;&nbsp;</a></span>CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_HW_TS_MAX_NBR_CONCURRENT_TIMER&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The user may define the maximum number of virtual timers supported. </p>
<p >It shall not exceed 255 </p>

</div>
</div>
<a id="a02c36ea61714eb54bacc5b28cfe461b7" name="a02c36ea61714eb54bacc5b28cfe461b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c36ea61714eb54bacc5b28cfe461b7">&#9670;&nbsp;</a></span>CFG_HW_TS_NVIC_RTC_WAKEUP_IT_PREEMPTPRIO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_HW_TS_NVIC_RTC_WAKEUP_IT_PREEMPTPRIO&#160;&#160;&#160;    (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY + 1) /* FreeRTOS requirement */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The user may define the priority in the NVIC of the RTC_WKUP interrupt handler that is used to manage the wakeup timer. </p>
<p >This setting is the preemptpriority part of the NVIC. </p>

</div>
</div>
<a id="a464b56d7953e83306d7231a4f97a80d4" name="a464b56d7953e83306d7231a4f97a80d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464b56d7953e83306d7231a4f97a80d4">&#9670;&nbsp;</a></span>CFG_HW_TS_NVIC_RTC_WAKEUP_IT_SUBPRIO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_HW_TS_NVIC_RTC_WAKEUP_IT_SUBPRIO&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The user may define the priority in the NVIC of the RTC_WKUP interrupt handler that is used to manage the wakeup timer. </p>
<p >This setting is the subpriority part of the NVIC. It does not exist on all processors. When it is not supported on the CPU, the setting is ignored </p>

</div>
</div>
<a id="a3fa1fb93ee056623cf5422b462ad86ea" name="a3fa1fb93ee056623cf5422b462ad86ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa1fb93ee056623cf5422b462ad86ea">&#9670;&nbsp;</a></span>CFG_HW_TS_RTC_HANDLER_MAX_DELAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_HW_TS_RTC_HANDLER_MAX_DELAY&#160;&#160;&#160;(10 * (LSI_VALUE / 1000))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This value shall reflect the maximum delay there could be in the application between the time the RTC interrupt is generated by the Hardware and the time when the RTC interrupt handler is called. </p>
<p >This time is measured in number of RTCCLK ticks. A relaxed timing would be 10ms When the value is too short, the timerserver will not be able to count properly and all timeout may be random. When the value is too long, the device may wake up more often than the most optimal configuration. However, the impact on power consumption would be marginal (unless the value selected is extremely too long). It is strongly recommended to select a value large enough to make sure it is not too short to ensure reliability of the system as this will have marginal impact on low power mode </p>

</div>
</div>
<a id="a3eaf86fa3ec27befff69aa4c429b9bff" name="a3eaf86fa3ec27befff69aa4c429b9bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eaf86fa3ec27befff69aa4c429b9bff">&#9670;&nbsp;</a></span>CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a critical section in the Timer server The Timer server does not support the API to be nested The Application shall either: a) Ensure this will never happen b) Define the critical section The default implementations is masking all interrupts using the PRIMASK bit The TimerServer driver uses critical sections to avoid context corruption. </p>
<p >This is achieved with the macro TIMER_ENTER_CRITICAL_SECTION and TIMER_EXIT_CRITICAL_SECTION. When CFG_HW_TS_USE_PRIMASK_AS_CRITICAL_SECTION is set to 1, all STM32 interrupts are masked with the PRIMASK bit of the CortexM CPU. It is possible to use the BASEPRI register of the CortexM CPU to keep allowed some interrupts with high priority. In that case, the user shall re-implement TIMER_ENTER_CRITICAL_SECTION and TIMER_EXIT_CRITICAL_SECTION and shall make sure that no TimerServer API are called when the TIMER critical section is entered </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
